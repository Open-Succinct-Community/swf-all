/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.venky.swf.db;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.TimeZone;

import com.venky.core.date.DateUtils;

/**
 *
 * @author venky
 */
public class H2Helper extends JdbcTypeHelper{

	@Override
	public boolean isSavepointManagedByJdbc(){
    	return true;
    }
	public boolean isAutoCommitOnDDL(){
		return true;
	}

	@Override
    public String getAutoIncrementInstruction() {
            return (" INTEGER GENERATED BY DEFAULT AS IDENTITY ");
    }
	
    @Override
    public String getCurrentTimeStampKW(){
    	return "CURRENT_TIMESTAMP()";
    }
    @Override
    public String getCurrentDateKW(){
    	return "CURRENT_DATE()";
    }

    public String getForUpdateLiteral(){
    	return " FOR UPDATE ";
    }
    public boolean isQueryTimeoutSupported(){ 
		return true;
	}
    public boolean isNoWaitSupported(){
		return false;
	}
	public String getNoWaitLiteral(){
		return "";
	}
    
    
    @Override
	public String getDefaultKW(TypeRef<?> ref, Object value) {
    	if (value instanceof Boolean){
    		if ((Boolean)value){
    			return "1";
    		}else {
    			return "0";
    		}
    	}
    	return super.getDefaultKW(ref, value);
	}
    

    protected H2Helper() {
            /**
             * Specify size and scale for a data type only if the database accepts
             * them during table creation
             */
            registerjdbcSQLType(Boolean.class, new TypeRef<Boolean>(
                            java.sql.Types.BOOLEAN, "BOOLEAN", 0, 0, false,false,
                            new BooleanConverter()));
            registerjdbcSQLType(boolean.class, new TypeRef<Boolean>(
                            java.sql.Types.BOOLEAN, "BOOLEAN", 0, 0, false,false,
                            new BooleanConverter()));

            registerjdbcSQLType(Byte.class, new TypeRef<Byte>(java.sql.Types.TINYINT,
                            "TINYINT", 0, 0, false,false,new ByteConverter()));

            registerjdbcSQLType(byte.class, new TypeRef<Byte>(java.sql.Types.TINYINT,
                            "TINYINT", 0, 0, false,false,new ByteConverter()));

            registerjdbcSQLType(Short.class,
                            new TypeRef<Short>(java.sql.Types.SMALLINT, "SMALLINT", 0, 0,false,false,
                                            new ShortConverter()));
            registerjdbcSQLType(short.class,
                            new TypeRef<Short>(java.sql.Types.SMALLINT, "SMALLINT", 0, 0,false,false,
                                            new ShortConverter()));

            registerjdbcSQLType(Integer.class,
                            new TypeRef<Integer>(java.sql.Types.INTEGER, "INTEGER", 0, 0,false,false,
                                            new IntegerConverter()));
            registerjdbcSQLType(int.class, new TypeRef<Integer>(java.sql.Types.INTEGER, 
                            "INTEGER", 0, 0,false,false, new IntegerConverter()));

            registerjdbcSQLType(Long.class, new TypeRef<Long>(java.sql.Types.BIGINT,
                            "BIGINT", 0, 0, false,false,new LongConverter()));
            registerjdbcSQLType(long.class, new TypeRef<Long>(java.sql.Types.BIGINT,
                            "BIGINT", 0, 0, false,false, new LongConverter()));

            registerjdbcSQLType(BigDecimal.class, new TypeRef<BigDecimal>(
                            java.sql.Types.NUMERIC, "NUMERIC", 0, 0, false,false,
                            new BigDecimalConverter()));// also NUMERIC
            registerjdbcSQLType(BigDecimal.class, new TypeRef<BigDecimal>(
                    java.sql.Types.DECIMAL, "DECIMAL", 0, 0, false,false,
                    new BigDecimalConverter()));// also NUMERIC
            
            
            registerjdbcSQLType(Float.class, new TypeRef<Float>(java.sql.Types.REAL,
                            "REAL", 0, 0, false,false,new FloatConverter()));
            registerjdbcSQLType(float.class, new TypeRef<Float>(java.sql.Types.REAL,
                            "REAL", 0, 0, false,false,new FloatConverter()));

            registerjdbcSQLType(Double.class, new TypeRef<Double>(
                            java.sql.Types.REAL, "REAL", 0, 0,false,false, new DoubleConverter())); // ALSO
            registerjdbcSQLType(double.class, new TypeRef<Double>(
                            java.sql.Types.REAL, "REAL", 0, 0, false,false,new DoubleConverter())); // ALSO
                                                                                                                                                            // FLOAT

            registerjdbcSQLType(Date.class, new TypeRef<Date>(java.sql.Types.DATE,
                            "DATE", 0, 0, true,false,new DateConverter(DateUtils.ISO_DATE_FORMAT_STR,TimeZone.getDefault())));
            
            registerjdbcSQLType(Time.class, new TypeRef<Time>(
                            java.sql.Types.TIME, "TIME", 0, 0, true ,false, new TimeConverter(DateUtils.ISO_TIME_FORMAT_STR,TimeZone.getDefault())));
            
            registerjdbcSQLType(java.sql.Timestamp.class, new TypeRef<Timestamp>(
                            java.sql.Types.TIMESTAMP, "TIMESTAMP", 0, 0, true,false,
                            new TimestampConverter(DateUtils.ISO_DATE_TIME_FORMAT_STR,TimeZone.getDefault())));

            registerjdbcSQLType(String.class, new TypeRef<String>(
                            java.sql.Types.VARCHAR, "VARCHAR", 128, 0, true,true,
                            new StringConverter())); // ALSO CHAR, LONG VARCHAR

            registerjdbcSQLType(Reader.class, new TypeRef<Reader>(java.sql.Types.CLOB,
                            "CLOB", 0, 0, true , true,new ReaderConverter()));

            registerjdbcSQLType(InputStream.class, new TypeRef<InputStream>(java.sql.Types.BLOB,
                            "BLOB", 0, 0, true , true,new InputStreamConverter()));

    }
}
